///
/// camera.h
///
#pragma once
#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

class Camera {
public:
  Camera(float fov = 45.0f, float aspect = 16.0f / 9.0f, float near = 0.1f,
         float far = 10000.0f);

  void processInput(GLFWwindow *window, float deltaTime);
  void processMouseMovement(float xoffset, float yoffset,
                            bool constrainPitch = true);
  void processMouseScroll(float yoffset);

  glm::mat4 getViewMatrix() const;
  glm::mat4 getProjectionMatrix() const;

  glm::vec3 getPosition() const { return position; }
  glm::vec3 getFront() const { return front; }
  glm::vec3 getUp() const { return up; }
  float getFov() const { return fov; }

  void setAspectRatio(float aspect) {
    aspectRatio = aspect;
    updateProjectionMatrix();
  }

private:
  glm::vec3 position;
  glm::vec3 front;
  glm::vec3 up;
  glm::vec3 right;
  glm::vec3 worldUp;

  float yaw;
  float pitch;

  float movementSpeed;
  float mouseSensitivity;
  float zoom;

  float fov;
  float aspectRatio;
  float nearPlane;
  float farPlane;

  glm::mat4 projectionMatrix;

  void updateCameraVectors();
  void updateProjectionMatrix();
};
///
/// model_loader.h
///
#pragma once
#include <string>
#include <vector>

struct ModelData {
  std::vector<float> vertices;
  std::vector<unsigned int> indices;
  bool loaded = false;
};

class ModelLoader {
public:
  static ModelData loadOBJ(const std::string &filepath);
};
///
/// node_manager.h
///
#pragma once
#include "radio_system.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <string>
#include <vector>

class Camera;
class SpatialIndex;

class NodeManager {
public:
  NodeManager(RadioSystem &radioSystem);
  ~NodeManager();

  // Node creation and deletion
  int createNode(const glm::vec3 &position, float frequency = 2.4e9f,
                 float power = 20.0f, NodeType type = NodeType::TRANSMITTER);
  void deleteNode(int id);
  void deleteSelectedNode();

  // Node selection
  void selectNode(int id);
  void deselectAll();
  int getSelectedNodeId() const { return selectedNodeId; }
  RadioSource *getSelectedNode();

  // Node manipulation
  void moveSelectedNode(const glm::vec3 &newPosition);
  void setNodePosition(int id, const glm::vec3 &position);

  // Ray picking for node selection and placement
  int pickNode(const glm::vec3 &rayOrigin, const glm::vec3 &rayDirection,
               float maxDistance = 10000.0f);
  glm::vec3 pickPosition(const glm::vec3 &rayOrigin,
                         const glm::vec3 &rayDirection,
                         const SpatialIndex *spatialIndex, bool &hit);

  // Screen to world ray conversion
  static void screenToWorldRay(int mouseX, int mouseY, int screenWidth,
                               int screenHeight, const Camera &camera,
                               glm::vec3 &rayOrigin, glm::vec3 &rayDirection);

  // Placement mode
  void setPlacementMode(bool enabled) { placementMode = enabled; }
  bool isPlacementMode() const { return placementMode; }
  void setPlacementType(NodeType type) { placementNodeType = type; }
  NodeType getPlacementType() const { return placementNodeType; }

  // Get all nodes
  const std::vector<RadioSource> &getNodes() const {
    return radioSystem.getSources();
  }

  // Update (for animations, etc.)
  void update(float deltaTime);

private:
  RadioSystem &radioSystem;
  int selectedNodeId;
  bool placementMode;
  NodeType placementNodeType;

  // Helper function to check ray-sphere intersection for node picking
  bool raySphereIntersect(const glm::vec3 &rayOrigin,
                          const glm::vec3 &rayDirection,
                          const glm::vec3 &sphereCenter, float sphereRadius,
                          float &distance);
};

///
/// node_renderer.h
///
#pragma once
#include <GL/glew.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <string>
#include <vector>

class RadioSystem;

class NodeRenderer {
public:
  NodeRenderer();
  ~NodeRenderer();

  bool initialize();
  void render(const RadioSystem &radioSystem, const glm::mat4 &view,
              const glm::mat4 &projection);
  void renderPlacementPreview(const glm::vec3 &position, const glm::vec3 &color,
                              const glm::mat4 &view,
                              const glm::mat4 &projection);
  void cleanup();

private:
  // Sphere rendering for nodes
  GLuint nodeShaderProgram;
  GLuint sphereVAO, sphereVBO, sphereEBO;
  size_t sphereIndexCount;

  void createSphere(float radius, int segments);
  GLuint compileShader(const std::string &source, GLenum type);
  GLuint createShaderProgram(const std::string &vertexSource,
                             const std::string &fragmentSource);

  static const std::string nodeVertexShader;
  static const std::string nodeFragmentShader;
};

///
/// radio_system.h
///
#pragma once
#include <glm/glm.hpp>
#include <string>
#include <vector>

enum class NodeType { TRANSMITTER, RECEIVER, RELAY };

struct RadioSource {
  int id;
  std::string name;
  NodeType type;
  bool active;

  glm::vec3 position;
  glm::vec3 orientation;

  float frequency;
  float power;
  float antennaGain;
  float antennaHeight;

  glm::vec3 color;
  bool selected;
  bool visible;

  RadioSource(int nodeId, const glm::vec3 &pos, float freq, float pwr,
              NodeType nodeType = NodeType::TRANSMITTER)
      : id(nodeId), name("Node_" + std::to_string(nodeId)), type(nodeType),
        active(true), position(pos), orientation(0.0f, 0.0f, 0.0f),
        frequency(freq), power(pwr), antennaGain(0.0f), antennaHeight(0.0f),
        selected(false), visible(true) {
    color = frequencyToColor(freq);
  }

  static glm::vec3 frequencyToColor(float freq) {
    if (freq < 1e9)
      return glm::vec3(1.0f, 0.3f, 0.3f);
    else if (freq < 2.5e9)
      return glm::vec3(0.3f, 1.0f, 0.3f);
    else
      return glm::vec3(0.3f, 0.3f, 1.0f);
  }

  static const char *nodeTypeToString(NodeType type) {
    switch (type) {
    case NodeType::TRANSMITTER:
      return "Transmitter";
    case NodeType::RECEIVER:
      return "Receiver";
    case NodeType::RELAY:
      return "Relay";
    default:
      return "Unknown";
    }
  }
};

struct SignalRay {
  glm::vec3 origin;
  glm::vec3 direction;
  float strength;
  int bounces;
  glm::vec3 color;
  std::vector<glm::vec3> points;
};

class RadioSystem {
public:
  RadioSystem();
  ~RadioSystem();

  int addSource(const glm::vec3 &position, float frequency, float power,
                NodeType type = NodeType::TRANSMITTER);
  void removeSource(int id);
  void removeSourceByIndex(int index);
  RadioSource *getSourceById(int id);
  RadioSource *getSourceByIndex(int index);
  int getSourceCount() const { return sources.size(); }

  void update(float deltaTime);

  void computeSignalPropagation(const class SpatialIndex *spatialIndex);

  const std::vector<RadioSource> &getSources() const { return sources; }
  std::vector<RadioSource> &getSources() { return sources; }
  const std::vector<SignalRay> &getSignalRays() const { return signalRays; }

  void setRaysPerSource(int count) { raysPerSource = count; }
  void setMaxBounces(int count) { maxBounces = count; }
  void setMaxDistance(float dist) { maxDistance = dist; }

private:
  std::vector<RadioSource> sources;
  std::vector<SignalRay> signalRays;

  int nextNodeId;
  int raysPerSource;
  int maxBounces;
  float maxDistance;

  float calculatePathLoss(float distance, float frequency);
  float calculateReflectionLoss(const glm::vec3 &normal);
};

///
/// renderer.h
///
#pragma once
#include <GL/glew.h>

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <string>
#include <vector>

class Renderer {
public:
  Renderer();
  ~Renderer();

  bool initialize(int width, int height);
  void render(const glm::mat4 &view, const glm::mat4 &projection,
              const glm::mat4 &model = glm::mat4(1.0f));
  void cleanup();

  void setModelData(const std::vector<float> &vertices,
                    const std::vector<unsigned int> &indices);

private:
  GLuint shaderProgram;
  GLuint VAO, VBO, EBO;

  size_t indexCount;

  GLuint compileShader(const std::string &source, GLenum type);
  GLuint createShaderProgram(const std::string &vertexSource,
                             const std::string &fragmentSource);

  static const std::string vertexShaderSource;
  static const std::string fragmentShaderSource;
};
///
/// spatial_index.h
///
#pragma once
#include <glm/glm.hpp>
#include <memory>
#include <vector>

struct Triangle {
  glm::vec3 v0, v1, v2;
  glm::vec3 normal;
  unsigned int id;
};

struct BoundingBox {
  glm::vec3 min;
  glm::vec3 max;

  BoundingBox() : min(glm::vec3(FLT_MAX)), max(glm::vec3(-FLT_MAX)) {}
  BoundingBox(const glm::vec3 &min, const glm::vec3 &max)
      : min(min), max(max) {}

  void expand(const glm::vec3 &point) {
    min = glm::min(min, point);
    max = glm::max(max, point);
  }

  void expand(const BoundingBox &box) {
    min = glm::min(min, box.min);
    max = glm::max(max, box.max);
  }

  glm::vec3 centroid() const { return (min + max) * 0.5f; }

  float surfaceArea() const {
    glm::vec3 d = max - min;
    return 2.0f * (d.x * d.y + d.y * d.z + d.z * d.x);
  }

  bool intersect(const glm::vec3 &origin, const glm::vec3 &direction,
                 float tMin, float tMax) const {
    for (int i = 0; i < 3; i++) {
      float invD = 1.0f / direction[i];
      float t0 = (min[i] - origin[i]) * invD;
      float t1 = (max[i] - origin[i]) * invD;
      if (invD < 0.0f)
        std::swap(t0, t1);
      tMin = t0 > tMin ? t0 : tMin;
      tMax = t1 < tMax ? t1 : tMax;
      if (tMax <= tMin)
        return false;
    }
    return true;
  }
};

struct Ray {
  glm::vec3 origin;
  glm::vec3 direction;
  float tMin = 0.001f;
  float tMax = 10000.0f;
};

struct RayHit {
  bool hit = false;
  float distance = FLT_MAX;
  glm::vec3 point;
  glm::vec3 normal;
  unsigned int triangleId = 0;
};

struct BVHNode {
  BoundingBox bounds;
  std::unique_ptr<BVHNode> left;
  std::unique_ptr<BVHNode> right;
  std::vector<unsigned int> triangleIndices;
  bool isLeaf = false;
};

struct Building {
  std::vector<unsigned int> triangleIndices;
  BoundingBox bounds;
  glm::vec3 centroid;
  float height;
};

class SpatialIndex {
public:
  SpatialIndex();
  ~SpatialIndex();

  void build(const std::vector<Triangle> &triangles);
  RayHit intersect(const Ray &ray) const;
  bool intersectAny(const Ray &ray) const;

  // Serialization
  bool saveBVH(const std::string &filename) const;
  bool loadBVH(const std::string &filename);

  const std::vector<Triangle> &getTriangles() const { return m_triangles; }
  const BoundingBox &getBounds() const { return m_sceneBounds; }
  const std::vector<Building> &getBuildings() const { return m_buildings; }

  void extractBuildings();
  void printStats() const;

private:
  std::vector<Triangle> m_triangles;
  std::unique_ptr<BVHNode> m_root;
  BoundingBox m_sceneBounds;
  std::vector<Building> m_buildings;

  std::unique_ptr<BVHNode> buildBVH(std::vector<unsigned int> &triangleIndices,
                                    int depth);
  RayHit intersectBVH(const BVHNode *node, const Ray &ray) const;
  bool intersectAnyBVH(const BVHNode *node, const Ray &ray) const;
  bool intersectTriangle(const Ray &ray, const Triangle &tri, float &t,
                         glm::vec3 &hitPoint) const;

  // Serialization helpers
  void serializeBVHNode(std::ofstream &out, const BVHNode *node) const;
  std::unique_ptr<BVHNode> deserializeBVHNode(std::ifstream &in);
};

///
/// ui_manager.h
///
#pragma once
#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <string>

class Camera;
class NodeManager;

class UIManager {
public:
  UIManager();
  ~UIManager();

  // Initialize ImGui context and backends
  bool initialize(GLFWwindow *window,
                  const char *glsl_version = "#version 330");

  // Begin new ImGui frame
  void beginFrame();

  // Render all UI windows
  void render(const Camera &camera, float fps, float deltaTime,
              NodeManager *nodeManager = nullptr);

  // End frame and render ImGui
  void endFrame();

  // Cleanup ImGui resources
  void cleanup();

  // Check if mouse is over any ImGui window
  bool wantCaptureMouse() const;

  // Check if keyboard is captured by ImGui
  bool wantCaptureKeyboard() const;

  // Set whether mouse look mode is active (disables ImGui input capture)
  void setMouseLookMode(bool enabled);

  // UI state
  struct UIState {
    bool showControlPanel = true;
    bool showAboutWindow = false;
    bool showDemoWindow = false;
    bool showPerformanceWindow = true;
    bool showNodePanel = true;
  } state;

private:
  void renderControlPanel(const Camera &camera, float fps, float deltaTime);
  void renderAboutWindow();
  void renderPerformanceWindow(float fps, float deltaTime);
  void renderNodePanel(NodeManager *nodeManager);

  bool initialized = false;
  GLFWwindow *window = nullptr;

  // Performance tracking
  static const int FPS_SAMPLE_COUNT = 60;
  float fpsHistory[FPS_SAMPLE_COUNT] = {0};
  int fpsHistoryIndex = 0;
};

