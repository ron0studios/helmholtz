#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(r32f, binding = 0) uniform image3D Ex;
layout(r32f, binding = 1) uniform image3D Ey;
layout(r32f, binding = 2) uniform image3D Ez;
layout(r32f, binding = 3) uniform image3D Hx;
layout(r32f, binding = 4) uniform image3D Hy;
layout(r32f, binding = 5) uniform image3D Hz;

uniform sampler3D epsilon;
uniform sampler3D mu;
uniform sampler3D emission;

uniform int gridSize;

void main() {
    ivec3 pos = ivec3(gl_GlobalInvocationID.xyz);
    
    if (pos.x >= gridSize || pos.y >= gridSize || pos.z >= gridSize) {
        return;
    }
    
    // Get epsilon value
    vec3 texCoord = (vec3(pos) + 0.5) / float(gridSize);
    float eps = texture(epsilon, texCoord).r;
    
    // If inside solid material (high epsilon), force fields to zero
    if (eps > 10.0) {
        imageStore(Ex, pos, vec4(0.0));
        imageStore(Ey, pos, vec4(0.0));
        imageStore(Ez, pos, vec4(0.0));
        return;
    }
    
    // Compute curl of H
    float curlHx = 0.0;
    float curlHy = 0.0;
    float curlHz = 0.0;
    
    if (pos.y < gridSize - 1 && pos.z < gridSize - 1) {
        float Hz_yp = imageLoad(Hz, pos + ivec3(0, 1, 0)).r;
        float Hz_y = imageLoad(Hz, pos).r;
        float Hy_zp = imageLoad(Hy, pos + ivec3(0, 0, 1)).r;
        float Hy_z = imageLoad(Hy, pos).r;
        curlHx = (Hz_yp - Hz_y) - (Hy_zp - Hy_z);
    }
    
    if (pos.x < gridSize - 1 && pos.z < gridSize - 1) {
        float Hx_zp = imageLoad(Hx, pos + ivec3(0, 0, 1)).r;
        float Hx_z = imageLoad(Hx, pos).r;
        float Hz_xp = imageLoad(Hz, pos + ivec3(1, 0, 0)).r;
        float Hz_x = imageLoad(Hz, pos).r;
        curlHy = (Hx_zp - Hx_z) - (Hz_xp - Hz_x);
    }
    
    if (pos.x < gridSize - 1 && pos.y < gridSize - 1) {
        float Hy_xp = imageLoad(Hy, pos + ivec3(1, 0, 0)).r;
        float Hy_x = imageLoad(Hy, pos).r;
        float Hx_yp = imageLoad(Hx, pos + ivec3(0, 1, 0)).r;
        float Hx_y = imageLoad(Hx, pos).r;
        curlHz = (Hy_xp - Hy_x) - (Hx_yp - Hx_y);
    }
    
    // Update E field: dE/dt = (1/epsilon) * curl(H)
    float dt = 0.5;
    float Ex_new = imageLoad(Ex, pos).r + dt * curlHx / eps;
    float Ey_new = imageLoad(Ey, pos).r + dt * curlHy / eps;
    float Ez_new = imageLoad(Ez, pos).r + dt * curlHz / eps;
    
    // Add emission source
    float src = texture(emission, texCoord).r;
    Ez_new += src;
    
    // Absorbing boundary conditions (simple damping near edges)
    int boundary = 5;
    float damping = 1.0;
    if (pos.x < boundary || pos.x >= gridSize - boundary ||
        pos.y < boundary || pos.y >= gridSize - boundary ||
        pos.z < boundary || pos.z >= gridSize - boundary) {
        damping = 0.95;
    }
    
    imageStore(Ex, pos, vec4(Ex_new * damping, 0.0, 0.0, 0.0));
    imageStore(Ey, pos, vec4(Ey_new * damping, 0.0, 0.0, 0.0));
    imageStore(Ez, pos, vec4(Ez_new * damping, 0.0, 0.0, 0.0));
}
