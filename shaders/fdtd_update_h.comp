#version 430 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(r32f, binding = 0) uniform image3D Ex;
layout(r32f, binding = 1) uniform image3D Ey;
layout(r32f, binding = 2) uniform image3D Ez;
layout(r32f, binding = 3) uniform image3D Hx;
layout(r32f, binding = 4) uniform image3D Hy;
layout(r32f, binding = 5) uniform image3D Hz;

uniform sampler3D epsilon;
uniform int gridSize;

void main() {
    ivec3 pos = ivec3(gl_GlobalInvocationID.xyz);
    
    if (pos.x >= gridSize || pos.y >= gridSize || pos.z >= gridSize) {
        return;
    }
    
    // Check if inside solid material
    vec3 texCoord = (vec3(pos) + 0.5) / float(gridSize);
    float eps = texture(epsilon, texCoord).r;
    
    if (eps > 10.0) {
        imageStore(Hx, pos, vec4(0.0));
        imageStore(Hy, pos, vec4(0.0));
        imageStore(Hz, pos, vec4(0.0));
        return;
    }
    
    // Compute curl of E
    float curlEx = 0.0;
    float curlEy = 0.0;
    float curlEz = 0.0;
    
    if (pos.y > 0 && pos.z > 0) {
        float Ez_y = imageLoad(Ez, pos).r;
        float Ez_ym = imageLoad(Ez, pos - ivec3(0, 1, 0)).r;
        float Ey_z = imageLoad(Ey, pos).r;
        float Ey_zm = imageLoad(Ey, pos - ivec3(0, 0, 1)).r;
        curlEx = (Ez_y - Ez_ym) - (Ey_z - Ey_zm);
    }
    
    if (pos.x > 0 && pos.z > 0) {
        float Ex_z = imageLoad(Ex, pos).r;
        float Ex_zm = imageLoad(Ex, pos - ivec3(0, 0, 1)).r;
        float Ez_x = imageLoad(Ez, pos).r;
        float Ez_xm = imageLoad(Ez, pos - ivec3(1, 0, 0)).r;
        curlEy = (Ex_z - Ex_zm) - (Ez_x - Ez_xm);
    }
    
    if (pos.x > 0 && pos.y > 0) {
        float Ey_x = imageLoad(Ey, pos).r;
        float Ey_xm = imageLoad(Ey, pos - ivec3(1, 0, 0)).r;
        float Ex_y = imageLoad(Ex, pos).r;
        float Ex_ym = imageLoad(Ex, pos - ivec3(0, 1, 0)).r;
        curlEz = (Ey_x - Ey_xm) - (Ex_y - Ex_ym);
    }
    
    // Update H field: dH/dt = -(1/mu) * curl(E)
    float dt = 0.5;
    float Hx_new = imageLoad(Hx, pos).r - dt * curlEx;
    float Hy_new = imageLoad(Hy, pos).r - dt * curlEy;
    float Hz_new = imageLoad(Hz, pos).r - dt * curlEz;
    
    // Absorbing boundary conditions (PML-like with gradual damping)
    // Creates an absorbing layer at boundaries to prevent reflections
    int pmlThickness = 8;
    float damping = 1.0;
    
    // Calculate distance from nearest boundary
    int distToBoundary = min(min(pos.x, gridSize - 1 - pos.x),
                         min(min(pos.y, gridSize - 1 - pos.y),
                             min(pos.z, gridSize - 1 - pos.z)));
    
    if (distToBoundary < pmlThickness) {
        // Quadratic damping profile: stronger damping closer to boundary
        float depth = float(pmlThickness - distToBoundary) / float(pmlThickness);
        damping = 1.0 - 0.3 * depth * depth;
    }
    
    imageStore(Hx, pos, vec4(Hx_new * damping, 0.0, 0.0, 0.0));
    imageStore(Hy, pos, vec4(Hy_new * damping, 0.0, 0.0, 0.0));
    imageStore(Hz, pos, vec4(Hz_new * damping, 0.0, 0.0, 0.0));
}
